var keyringPGP = (function (e) { var t = {}; function r (n) { if (t[n]) return t[n].exports; var i = t[n] = {i: n, l: !1, exports: {}}; return e[n].call(i.exports, i, i.exports, r), i.l = !0, i.exports } return r.m = e, r.c = t, r.d = function (e, t, n) { r.o(e, t) || Object.defineProperty(e, t, {enumerable: !0, get: n}) }, r.r = function (e) { typeof Symbol !== 'undefined' && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {value: 'Module'}), Object.defineProperty(e, '__esModule', {value: !0}) }, r.t = function (e, t) { if (1 & t && (e = r(e)), 8 & t) return e; if (4 & t && typeof e === 'object' && e && e.__esModule) return e; var n = Object.create(null); if (r.r(n), Object.defineProperty(n, 'default', {enumerable: !0, value: e}), 2 & t && typeof e !== 'string') for (var i in e)r.d(n, i, function (t) { return e[t] }.bind(null, i)); return n }, r.n = function (e) { var t = e && e.__esModule ? function () { return e.default } : function () { return e }; return r.d(t, 'a', t), t }, r.o = function (e, t) { return Object.prototype.hasOwnProperty.call(e, t) }, r.p = '', r(r.s = 0) }([function (e, t, r) { const n = r(1); let i = new openpgp.Keyring(); e.exports = {generate: async function (e) { var t = await openpgp.generateKey(e); return await this.importPublicKey(t.publicKeyArmored), await this.importPrivateKey(t.privateKeyArmored), this.store(), await this.unlock(e.passphrase), t }, clear: async function () { i.clear() }, store: async function () { i.store() }, listKeys: async function () { return i.publicKeys.keys.map(e => e.primaryKey.getFingerprint()) }, importPublicKey: async function (e) { await i.publicKeys.importKey(e), await this.store() }, importPrivateKey: async function (e) { await i.privateKeys.importKey(e), await this.store() }, getPublicKey: async function (e) { return n.lf(i.publicKeys.getForId(e).armor()).trim() }, getPrivateKey: async function (e) { return n.lf(i.privateKeys.getForId(e).armor()).trim() }, isLocked: async function (e) { return !i.privateKeys.getForId(e).primaryKey.isDecrypted }, unlockKey: async function (e, t) { if (await this.isLocked(e)) return i.privateKeys.getForId(e).decrypt(t) }, lockKey: async function (e, t) { i = new openpgp.Keyring() }, sign: async function (e, t) { return (await openpgp.sign({data: e, privateKeys: [i.privateKeys.getForId(t)], detached: !0})).signature }, verify: async function (e, t, r) { let n; return typeof r === 'string' && (r = [r]), n = t ? {message: openpgp.message.fromText(e), signature: openpgp.signature.readArmored(t), publicKeys: r.map(e => i.publicKeys.getForId(e))} : {message: openpgp.cleartext.readArmored(e), publicKeys: r.map(e => i.publicKeys.getForId(e.toLowerCase()))}, (await openpgp.verify(n)).signatures.forEach(e => { if (e.valid) { var t = r.indexOf(e.keyid.toHex().toUpperCase()); t >= 0 ? r = r.splice(t, 1) : (t = r.indexOf(i.publicKeys.getForId(e.keyid.toHex()).primaryKey.getFingerprint().toUpperCase())) >= 0 && r.splice(t, 1) } }), r.length === 0 }, decrypt: async function (e, t) { return (await openpgp.decrypt({message: openpgp.message.readArmored(e), privateKeys: [i.privateKeys.getForId(t)]})).data }, encrypt: async function (e, t) { return (await openpgp.encrypt({data: e, publicKeys: i.publicKeys.getForId(t), privateKeys: [i.privateKeys.getForId(t)]})).data }} }, function (e, t, r) { (function (t) { !(function (t, r, n) { void 0 !== e && e.exports ? e.exports = n() : t.eol = n() }(this, 0, function () { var e = {}; var r = void 0 !== t && t.platform === 'win32' ? '\r\n' : '\n'; var n = /\r\n|\r|\n/g; function i (e) { function t (t) { return t.replace(n, e) } return t.toString = function () { return e }, t } return e.lf = i('\n'), e.cr = i('\r'), e.crlf = i('\r\n'), e.auto = i(r), e.before = function (e) { return r + e }, e.after = function (e) { return e + r }, e.split = function (e) { return e.split(n) }, e })) }).call(this, r(2)) }, function (e, t) { var r; var n; var i = e.exports = {}; function o () { throw new Error('setTimeout has not been defined') } function a () { throw new Error('clearTimeout has not been defined') } function u (e) { if (r === setTimeout) return setTimeout(e, 0); if ((r === o || !r) && setTimeout) return r = setTimeout, setTimeout(e, 0); try { return r(e, 0) } catch (t) { try { return r.call(null, e, 0) } catch (t) { return r.call(this, e, 0) } } }!(function () { try { r = typeof setTimeout === 'function' ? setTimeout : o } catch (e) { r = o } try { n = typeof clearTimeout === 'function' ? clearTimeout : a } catch (e) { n = a } }()); var c; var s = []; var p = !1; var f = -1; function l () { p && c && (p = !1, c.length ? s = c.concat(s) : f = -1, s.length && y()) } function y () { if (!p) { var e = u(l); p = !0; for (var t = s.length; t;) { for (c = s, s = []; ++f < t;)c && c[f].run(); f = -1, t = s.length }c = null, p = !1, (function (e) { if (n === clearTimeout) return clearTimeout(e); if ((n === a || !n) && clearTimeout) return n = clearTimeout, clearTimeout(e); try { n(e) } catch (t) { try { return n.call(null, e) } catch (t) { return n.call(this, e) } } }(e)) } } function d (e, t) { this.fun = e, this.array = t } function g () {}i.nextTick = function (e) { var t = new Array(arguments.length - 1); if (arguments.length > 1) for (var r = 1; r < arguments.length; r++)t[r - 1] = arguments[r]; s.push(new d(e, t)), s.length !== 1 || p || u(y) }, d.prototype.run = function () { this.fun.apply(null, this.array) }, i.title = 'browser', i.browser = !0, i.env = {}, i.argv = [], i.version = '', i.versions = {}, i.on = g, i.addListener = g, i.once = g, i.off = g, i.removeListener = g, i.removeAllListeners = g, i.emit = g, i.prependListener = g, i.prependOnceListener = g, i.listeners = function (e) { return [] }, i.binding = function (e) { throw new Error('process.binding is not supported') }, i.cwd = function () { return '/' }, i.chdir = function (e) { throw new Error('process.chdir is not supported') }, i.umask = function () { return 0 } }]))
